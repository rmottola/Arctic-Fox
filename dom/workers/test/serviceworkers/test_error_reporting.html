<!DOCTYPE HTML>
<html>
<head>
  <title>Test Error Reporting of Service Worker Failures</title>
  <script src="/tests/SimpleTest/SimpleTest.js"></script>
  <script src="/tests/SimpleTest/SpawnTask.js"></script>
  <link rel="stylesheet" href="/tests/SimpleTest/test.css"/>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
</head>
<body>

<script type="text/javascript">
"use strict";
/**
 * Test that a bunch of service worker coding errors and failure modes that
 * might otherwise be hard to diagnose are surfaced as console error messages.
 * The driving use-case is minimizing cursing from a developer looking at a
 * document in Firefox testing a page that involves service workers.
 *
 * This test assumes that errors will be reported via
 * ServiceWorkerManager::ReportToAllClients and that that method is reliable and
 * tested via some other file.  Because this generates nsIScriptError instances
 * with flattened strings (the interpolated arguments aren't kept around), we
 * load the string bundle and use it to derive the exact string message we
 * expect for the given payload.
 **/

let stringBundleService =
  SpecialPowers.Cc["@mozilla.org/intl/stringbundle;1"]
               .getService(SpecialPowers.Ci.nsIStringBundleService);
let localizer =
  stringBundleService.createBundle("chrome://global/locale/dom/dom.properties");

/**
 * Start monitoring the console for the given localized error message string
 * with the given arguments to be logged.  Call before running code that will
 * generate the console message.  Pair with a call to
 * `wait_for_expected_message` invoked after the message should have been
 * generated.
 *
 * @param {String} msgId
 *   The localization message identifier used in the properties file.
 * @param {String[]} args
 *   The list of formatting arguments we expect the error to be generated with.
 * @return {Object} Promise/handle to pass to wait_for_expected_message.
 */
function expect_console_message(msgId, args) {
  let expectedString = localizer.formatStringFromName(msgId, args, args.length);
  return new Promise(resolve => {
    SimpleTest.monitorConsole(resolve, [{ errorMessage: expectedString }])
  });
}

/**
 * Stop monitoring the console, returning a Promise that will be resolved when
 * the sentinel console message sent through the async data path has been
 * received.  The Promise will not reject on failure; instead a mochitest
 * failure will have been generated by ok(false)/equivalent by the time it is
 * resolved.
 */
function wait_for_expected_message(expectedPromise) {
  SimpleTest.endMonitorConsole();
  return expectedPromise;
}

/**
 * Derive an absolute URL string from a relative URL to simplify error message
 * argument generation.
 */
function make_absolute_url(relUrl) {
  return new URL(relUrl, window.location).href;
}

add_task(function setupPrefs() {
  return SpecialPowers.pushPrefEnv({"set": [
    ["dom.serviceWorkers.enabled", true],
    ["dom.serviceWorkers.testing.enabled", true],
    ["dom.caches.testing.enabled", true],
  ]});
});

/**
 * Ensure an error is logged during the initial registration of a SW when a 404
 * is received.
 */
add_task(function* register_404() {
  // Start monitoring for the error
  let expectedMessage = expect_console_message(
    "ServiceWorkerRegisterNetworkError",
    [make_absolute_url("network_error/"), "404", make_absolute_url("404.js")]);

  // Register, generating the 404 error.  This will reject with a TypeError
  // which we need to consume so it doesn't get thrown at our generator.
  yield navigator.serviceWorker.register("404.js", { scope: "network_error/" })
    .then(
      () => { ok(false, "should have rejected"); },
      (e) => { ok(e.name === "TypeError", "404 failed as expected"); });

  yield wait_for_expected_message(expectedMessage);
});
</script>

</body>
</html>
