diff --git a/js/src/asmjs/WasmCompile.cpp b/js/src/asmjs/WasmCompile.cpp
index 6b1f0344f09fcc..4fd969a7ec02de 100644
--- a/js/src/asmjs/WasmCompile.cpp
+++ b/js/src/asmjs/WasmCompile.cpp
@@ -613,7 +613,7 @@ DecodeFunctionSection(Decoder& d, ModuleGeneratorData* init)
 }
 
 static UniqueChars
-MaybeDecodeName(Decoder& d)
+DecodeName(Decoder& d)
 {
     uint32_t numBytes;
     if (!d.readVarU32(&numBytes))
@@ -774,28 +774,22 @@ DecodeImport(Decoder& d, bool newFormat, ModuleGeneratorData* init, ImportVector
         if (!init->funcImports.emplaceBack(sig))
             return false;
 
-        UniqueChars moduleName = MaybeDecodeName(d);
+        UniqueChars moduleName = DecodeName(d);
         if (!moduleName)
             return Fail(d, "expected valid import module name");
 
-        if (!strlen(moduleName.get()))
-            return Fail(d, "module name cannot be empty");
-
-        UniqueChars funcName = MaybeDecodeName(d);
+        UniqueChars funcName = DecodeName(d);
         if (!funcName)
             return Fail(d, "expected valid import func name");
 
         return imports->emplaceBack(Move(moduleName), Move(funcName), DefinitionKind::Function);
     }
 
-    UniqueChars moduleName = MaybeDecodeName(d);
+    UniqueChars moduleName = DecodeName(d);
     if (!moduleName)
         return Fail(d, "expected valid import module name");
 
-    if (!strlen(moduleName.get()))
-        return Fail(d, "module name cannot be empty");
-
-    UniqueChars funcName = MaybeDecodeName(d);
+    UniqueChars funcName = DecodeName(d);
     if (!funcName)
         return Fail(d, "expected valid import func name");
 
@@ -1074,7 +1068,7 @@ typedef HashSet<const char*, CStringHasher, SystemAllocPolicy> CStringSet;
 static UniqueChars
 DecodeExportName(Decoder& d, CStringSet* dupSet)
 {
-    UniqueChars exportName = MaybeDecodeName(d);
+    UniqueChars exportName = DecodeName(d);
     if (!exportName) {
         Fail(d, "expected valid export name");
         return nullptr;
diff --git a/js/src/asmjs/WasmJS.cpp b/js/src/asmjs/WasmJS.cpp
index b3cfd88633e876..5ed05f54adb10d 100644
--- a/js/src/asmjs/WasmJS.cpp
+++ b/js/src/asmjs/WasmJS.cpp
@@ -106,14 +106,12 @@ GetImports(JSContext* cx,
         if (!GetProperty(cx, importObj, import.module.get(), &v))
             return false;
 
-        if (strlen(import.func.get()) > 0) {
-            if (!v.isObject())
-                return Throw(cx, JSMSG_WASM_BAD_IMPORT_FIELD, "an Object");
+        if (!v.isObject())
+            return Throw(cx, JSMSG_WASM_BAD_IMPORT_FIELD, "an Object");
 
-            RootedObject obj(cx, &v.toObject());
-            if (!GetProperty(cx, obj, import.func.get(), &v))
-                return false;
-        }
+        RootedObject obj(cx, &v.toObject());
+        if (!GetProperty(cx, obj, import.func.get(), &v))
+            return false;
 
         switch (import.kind) {
           case DefinitionKind::Function:
diff --git a/js/src/jit-test/tests/wasm/basic-control-flow.js b/js/src/jit-test/tests/wasm/basic-control-flow.js
index 867526391a2c26..ac0a68bbc10878 100644
--- a/js/src/jit-test/tests/wasm/basic-control-flow.js
+++ b/js/src/jit-test/tests/wasm/basic-control-flow.js
@@ -47,9 +47,9 @@ assertEq(wasmEvalText(`(module
 
 // The if (resp. else) branch is taken iff the condition is true (resp. false)
 counter = 0;
-var imports = { inc() { counter++ } };
+var imports = { "":{inc() { counter++ }} };
 assertEq(wasmEvalText(`(module
-    (import "inc" "" (result i32))
+    (import "" "inc" (result i32))
     (func
         (result i32)
         (if
@@ -63,7 +63,7 @@ assertEq(wasmEvalText(`(module
 assertEq(counter, 0);
 
 assertEq(wasmEvalText(`(module
-    (import "inc" "" (result i32))
+    (import "" "inc" (result i32))
     (func
         (result i32)
         (if
@@ -77,7 +77,7 @@ assertEq(wasmEvalText(`(module
 assertEq(counter, 0);
 
 assertEq(wasmEvalText(`(module
-    (import "inc" "" (result i32))
+    (import "" "inc" (result i32))
     (func
         (if
             (i32.const 0)
@@ -89,7 +89,7 @@ assertEq(wasmEvalText(`(module
 assertEq(counter, 0);
 
 assertEq(wasmEvalText(`(module
-    (import "inc" "" (result i32))
+    (import "" "inc" (result i32))
     (func
         (if
             (i32.const 1)
@@ -103,7 +103,7 @@ assertEq(counter, 1);
 // One can chain if with if/if
 counter = 0;
 assertEq(wasmEvalText(`(module
-    (import "inc" "" (result i32))
+    (import "" "inc" (result i32))
     (func
         (result i32)
         (if
@@ -212,13 +212,13 @@ assertEq(wasmEvalText(`(module (func (result i32)
 
 var notcalled = false;
 var called = false;
-var imports = {
+var imports = {"": {
     notcalled() {notcalled = true},
     called() {called = true}
-};
+}};
 assertEq(wasmEvalText(`(module
-(import "notcalled" "")
-(import "called" "")
+(import "" "notcalled")
+(import "" "called")
 (func
   (block
     (return (br 0))
diff --git a/js/src/jit-test/tests/wasm/basic.js b/js/src/jit-test/tests/wasm/basic.js
index 42e3314fd60800..7e71499aee7d33 100644
--- a/js/src/jit-test/tests/wasm/basic.js
+++ b/js/src/jit-test/tests/wasm/basic.js
@@ -103,22 +103,22 @@ assertErrorMessage(() => wasmEvalText(code, {a:{b:1}}), TypeError, notFunction);
 wasmEvalText(code, {a:{b:()=>{}}});
 
 var code = '(module (import "" "b"))';
-assertErrorMessage(() => wasmEvalText(code), TypeError, /module name cannot be empty/);
+wasmEvalText(code, {"":{b:()=>{}}});
 
 var code = '(module (import "a" ""))';
 assertErrorMessage(() => wasmEvalText(code), TypeError, noImportObj);
-assertErrorMessage(() => wasmEvalText(code, {}), TypeError, notFunction);
-assertErrorMessage(() => wasmEvalText(code, {a:1}), TypeError, notFunction);
-wasmEvalText(code, {a:()=>{}});
+assertErrorMessage(() => wasmEvalText(code, {}), TypeError, notObject);
+assertErrorMessage(() => wasmEvalText(code, {a:1}), TypeError, notObject);
+wasmEvalText(code, {a:{"":()=>{}}});
 
 var code = '(module (import "a" "") (import "b" "c") (import "c" ""))';
 assertErrorMessage(() => wasmEvalText(code, {a:()=>{}, b:{c:()=>{}}, c:{}}), TypeError, notFunction);
-wasmEvalText(code, {a:()=>{}, b:{c:()=>{}}, c:()=>{}});
+wasmEvalText(code, {a:{"":()=>{}}, b:{c:()=>{}}, c:{"":()=>{}}});
 
-wasmEvalText('(module (import "a" "" (result i32)))', {a: ()=> {}});
-wasmEvalText('(module (import "a" "" (result f32)))', {a: ()=> {}});
-wasmEvalText('(module (import "a" "" (result f64)))', {a: ()=> {}});
-wasmEvalText('(module (import $foo "a" "" (result f64)))', {a: ()=> {}});
+wasmEvalText('(module (import "a" "" (result i32)))', {a:{"":()=>{}}});
+wasmEvalText('(module (import "a" "" (result f32)))', {a:{"":()=>{}}});
+wasmEvalText('(module (import "a" "" (result f64)))', {a:{"":()=>{}}});
+wasmEvalText('(module (import $foo "a" "" (result f64)))', {a:{"":()=>{}}});
 
 // ----------------------------------------------------------------------------
 // memory
@@ -293,12 +293,12 @@ assertThrowsInstanceOf(() => wasmEvalText('(module (import "a" "") (func (call_i
 assertThrowsInstanceOf(() => wasmEvalText('(module (import "a" "" (param i32)) (func (call_import 0)))', {a:()=>{}}), TypeError);
 assertThrowsInstanceOf(() => wasmEvalText('(module (import "a" "" (param f32)) (func (call_import 0 (i32.const 0))))', {a:()=>{}}), TypeError);
 assertErrorMessage(() => wasmEvalText('(module (import "a" "") (func (call_import 1)))'), TypeError, /import index out of range/);
-wasmEvalText('(module (import "a" "") (func (call_import 0)))', {a:()=>{}});
-wasmEvalText('(module (import "a" "" (param i32)) (func (call_import 0 (i32.const 0))))', {a:()=>{}});
+wasmEvalText('(module (import "" "a") (func (call_import 0)))', {"":{a:()=>{}}});
+wasmEvalText('(module (import "" "a" (param i32)) (func (call_import 0 (i32.const 0))))', {"":{a:()=>{}}});
 
 function checkF32CallImport(v) {
-    assertEq(wasmEvalText('(module (import "a" "" (result f32)) (func (result f32) (call_import 0)) (export "" 0))', {a:()=>{ return v; }})(), Math.fround(v));
-    wasmEvalText('(module (import "a" "" (param f32)) (func (param f32) (call_import 0 (get_local 0))) (export "" 0))', {a:x=>{ assertEq(Math.fround(v), x); }})(v);
+    assertEq(wasmEvalText('(module (import "" "a" (result f32)) (func (result f32) (call_import 0)) (export "" 0))', {"":{a:()=>{ return v; }}})(), Math.fround(v));
+    wasmEvalText('(module (import "" "a" (param f32)) (func (param f32) (call_import 0 (get_local 0))) (export "" 0))', {"":{a:x=>{ assertEq(Math.fround(v), x); }}})(v);
 }
 checkF32CallImport(13.37);
 checkF32CallImport(NaN);
@@ -306,29 +306,29 @@ checkF32CallImport(-Infinity);
 checkF32CallImport(-0);
 checkF32CallImport(Math.pow(2, 32) - 1);
 
-var f = wasmEvalText('(module (import "inc" "") (func (call_import 0)) (export "" 0))', {inc:()=>counter++});
-var g = wasmEvalText('(module (import "f" "") (func (block (call_import 0) (call_import 0))) (export "" 0))', {f});
+var f = wasmEvalText('(module (import "" "inc") (func (call_import 0)) (export "" 0))', {"":{inc:()=>counter++}});
+var g = wasmEvalText('(module (import "" "f") (func (block (call_import 0) (call_import 0))) (export "" 0))', {"":{f}});
 var counter = 0;
 f();
 assertEq(counter, 1);
 g();
 assertEq(counter, 3);
 
-var f = wasmEvalText('(module (import "callf" "") (func (call_import 0)) (export "" 0))', {callf:()=>f()});
+var f = wasmEvalText('(module (import "" "callf") (func (call_import 0)) (export "" 0))', {"":{callf:()=>f()}});
 assertThrowsInstanceOf(() => f(), InternalError);
 
-var f = wasmEvalText('(module (import "callg" "") (func (call_import 0)) (export "" 0))', {callg:()=>g()});
-var g = wasmEvalText('(module (import "callf" "") (func (call_import 0)) (export "" 0))', {callf:()=>f()});
+var f = wasmEvalText('(module (import "" "callg") (func (call_import 0)) (export "" 0))', {"":{callg:()=>g()}});
+var g = wasmEvalText('(module (import "" "callf") (func (call_import 0)) (export "" 0))', {"":{callf:()=>f()}});
 assertThrowsInstanceOf(() => f(), InternalError);
 
-var code = '(module (import "one" "" (result i32)) (import "two" "" (result i32)) (func (result i32) (i32.const 3)) (func (result i32) (i32.const 4)) (func (result i32) BODY) (export "" 2))';
-var imports = {one:()=>1, two:()=>2};
+var code = '(module (import "" "one" (result i32)) (import "" "two" (result i32)) (func (result i32) (i32.const 3)) (func (result i32) (i32.const 4)) (func (result i32) BODY) (export "" 2))';
+var imports = {"":{one:()=>1, two:()=>2}};
 assertEq(wasmEvalText(code.replace('BODY', '(call_import 0)'), imports)(), 1);
 assertEq(wasmEvalText(code.replace('BODY', '(call_import 1)'), imports)(), 2);
 assertEq(wasmEvalText(code.replace('BODY', '(call 0)'), imports)(), 3);
 assertEq(wasmEvalText(code.replace('BODY', '(call 1)'), imports)(), 4);
 
-assertEq(wasmEvalText(`(module (import "evalcx" "" (param i32) (result i32)) (func (result i32) (call_import 0 (i32.const 0))) (export "" 0))`, {evalcx})(), 0);
+assertEq(wasmEvalText(`(module (import "" "evalcx" (param i32) (result i32)) (func (result i32) (call_import 0 (i32.const 0))) (export "" 0))`, {"":{evalcx}})(), 0);
 
 if (typeof evaluate === 'function')
     evaluate(`Wasm.instantiateModule(wasmTextToBinary('(module)')) `, { fileName: null });
@@ -336,7 +336,7 @@ if (typeof evaluate === 'function')
 {
     setJitCompilerOption('wasm.test-mode', 1);
 
-    let imp = {
+    let imp = {"":{
         param(i64) {
             assertEqI64(i64, {
                 low: 0x9abcdef0,
@@ -358,27 +358,27 @@ if (typeof evaluate === 'function')
             i64.low = 1337;
             return i64;
         }
-    }
+    }}
 
     assertEq(wasmEvalText(`(module
-        (import "param" "" (param i64) (result i32))
+        (import "" "param" (param i64) (result i32))
         (func (result i32) (call_import 0 (i64.const 0x123456789abcdef0)))
         (export "" 0))`, imp)(), 42);
 
     assertEq(wasmEvalText(`(module
-        (import "param" "" (param i64)(param i64)(param i64)(param i64)(param i64)(param i64)(param i64) (param i64) (result i32))
+        (import "" "param" (param i64)(param i64)(param i64)(param i64)(param i64)(param i64)(param i64) (param i64) (result i32))
         (func (result i32) (call_import 0 (i64.const 0x123456789abcdef0)(i64.const 0x123456789abcdef0)(i64.const 0x123456789abcdef0)(i64.const 0x123456789abcdef0)(i64.const 0x123456789abcdef0)(i64.const 0x123456789abcdef0)(i64.const 0x123456789abcdef0)(i64.const 0x123456789abcdef0)))
         (export "" 0))`, imp)(), 42);
 
     assertEqI64(wasmEvalText(`(module
-        (import "result" "" (param i32) (result i64))
+        (import "" "result" (param i32) (result i64))
         (func (result i64) (call_import 0 (i32.const 3)))
         (export "" 0))`, imp)(), { low: 0xabcdef01, high: 0x1234567b });
 
     // Ensure the ion exit is never taken.
     let ionThreshold = 2 * getJitCompilerOptions()['ion.warmup.trigger'];
     assertEqI64(wasmEvalText(`(module
-        (import "paramAndResult" "" (param i64) (result i64))
+        (import "" "paramAndResult" (param i64) (result i64))
         (func (result i64) (local i32) (local i64)
          (set_local 0 (i32.const 0))
          (loop $out $in
@@ -444,14 +444,14 @@ assertErrorMessage(() => i2v(5), Error, badIndirectCall);
     assertEq(wasmEvalText(
         `(module
             (type $v2v (func))
-            (import $foo "f" "")
+            (import $foo "" "f")
             (func $a (call_import $foo))
             (func $b (result i32) (i32.const 0))
             (table $a $b)
             (func $bar (call_indirect $v2v (i32.const 0)))
             (export "" $bar)
         )`,
-        {f:() => { stack = new Error().stack }}
+        {"":{f:() => { stack = new Error().stack }}}
     )(), undefined);
 
     disableSPSProfiling();
@@ -471,7 +471,7 @@ for (bad of [6, 7, 100, Math.pow(2,31)-1, Math.pow(2,31), Math.pow(2,31)+1, Math
 
 wasmEvalText('(module (func $foo (nop)) (func (call $foo)))');
 wasmEvalText('(module (func (call $foo)) (func $foo (nop)))');
-wasmEvalText('(module (import $bar "a" "") (func (call_import $bar)) (func $foo (nop)))', {a:()=>{}});
+wasmEvalText('(module (import $bar "" "a") (func (call_import $bar)) (func $foo (nop)))', {"":{a:()=>{}}});
 
 
 // ----------------------------------------------------------------------------
@@ -491,16 +491,16 @@ assertEq(wasmEvalText('(module (func) (func (select (call 0) (call 0) (i32.const
 var numT = 0;
 var numF = 0;
 
-var imports = {
+var imports = {"": {
     ifTrue: () => 1 + numT++,
     ifFalse: () => -1 + numF++,
-}
+}}
 
 // Test that side-effects are applied on both branches.
 var f = wasmEvalText(`
 (module
- (import "ifTrue" "" (result i32))
- (import "ifFalse" "" (result i32))
+ (import "" "ifTrue" (result i32))
+ (import "" "ifFalse" (result i32))
  (func (result i32) (param i32)
   (select
    (call_import 0)
diff --git a/js/src/jit-test/tests/wasm/binary.js b/js/src/jit-test/tests/wasm/binary.js
index 67c242a8a4e747..59bde38ffd7895 100644
--- a/js/src/jit-test/tests/wasm/binary.js
+++ b/js/src/jit-test/tests/wasm/binary.js
@@ -229,14 +229,14 @@ assertThrowsInstanceOf(() => wasmEval(moduleWithSections([sigSection([v2vSig]),
 assertErrorMessage(() => wasmEval(moduleWithSections([importSection([{sigIndex:0, module:"a", func:"b"}])])), TypeError, /signature index out of range/);
 assertErrorMessage(() => wasmEval(moduleWithSections([sigSection([v2vSig]), importSection([{sigIndex:1, module:"a", func:"b"}])])), TypeError, /signature index out of range/);
 wasmEval(moduleWithSections([sigSection([v2vSig]), importSection([])]));
-wasmEval(moduleWithSections([sigSection([v2vSig]), importSection([{sigIndex:0, module:"a", func:""}])]), {a:()=>{}});
+wasmEval(moduleWithSections([sigSection([v2vSig]), importSection([{sigIndex:0, module:"a", func:""}])]), {a:{"":()=>{}}});
 
 wasmEval(moduleWithSections([
     sigSection([v2vSig]),
     importSection([{sigIndex:0, module:"a", func:""}]),
     declSection([0]),
     bodySection([v2vBody])
-]), {a:()=>{}});
+]), {a:{"":()=>{}}});
 
 assertErrorMessage(() => wasmEval(moduleWithSections([ {name: dataSegmentsId, body: [], } ])), TypeError, /data section requires a memory section/);
 
diff --git a/js/src/jit-test/tests/wasm/start.js b/js/src/jit-test/tests/wasm/start.js
index e0741877be1889..d1237417cec551 100644
--- a/js/src/jit-test/tests/wasm/start.js
+++ b/js/src/jit-test/tests/wasm/start.js
@@ -14,12 +14,12 @@ assertErrorMessage(() => wasmEvalText('(module (func (result f32)) (start 0))'),
 // Basic use case.
 var count = 0;
 function inc() { count++; }
-var exports = wasmEvalText(`(module (import $imp "inc" "") (func $f (param i32)) (func (call_import $imp)) (start $f))`, { inc });
+var exports = wasmEvalText(`(module (import $imp "" "inc") (func $f (param i32)) (func (call_import $imp)) (start $f))`, { "":{inc} });
 assertEq(count, 1);
 assertEq(Object.keys(exports).length, 0);
 
 count = 0;
-exports = wasmEvalText(`(module (import "inc" "") (func $start (call_import 0)) (start $start) (export "" 0))`, { inc });
+exports = wasmEvalText(`(module (import "" "inc") (func $start (call_import 0)) (start $start) (export "" 0))`, { "":{inc} });
 assertEq(count, 1);
 assertEq(typeof exports, 'function');
 assertEq(exports(), undefined);
@@ -31,24 +31,24 @@ const Instance = WebAssembly.Instance;
 const textToBinary = str => wasmTextToBinary(str, 'new-format');
 
 count = 0;
-const m = new Module(textToBinary('(module (import $imp "inc" "") (func) (func $start (call $imp)) (start $start) (export "" $start))'));
+const m = new Module(textToBinary('(module (import $imp "" "inc") (func) (func $start (call $imp)) (start $start) (export "" $start))'));
 assertEq(count, 0);
 
 assertErrorMessage(() => new Instance(m), TypeError, /no import object given/);
 assertEq(count, 0);
 
-const i1 = new Instance(m, { inc });
+const i1 = new Instance(m, { "":{inc} });
 assertEq(count, 1);
 i1.exports[""]();
 assertEq(count, 2);
 
-const i2 = new Instance(m, { inc });
+const i2 = new Instance(m, { "":{inc} });
 assertEq(count, 3);
 
 function fail() { assertEq(true, false); }
 
 count = 0;
-const m2 = new Module(textToBinary('(module (import "fail" "") (import $imp "inc" "") (func) (start $imp))'));
+const m2 = new Module(textToBinary('(module (import "" "fail") (import $imp "" "inc") (func) (start $imp))'));
 assertEq(count, 0);
-new Instance(m2, { inc, fail });
+new Instance(m2, {"":{ inc, fail }});
 assertEq(count, 1);
