diff --git a/dom/plugins/base/PluginPRLibrary.cpp b/dom/plugins/base/PluginPRLibrary.cpp
index a79735d88605dd..2b414a4d6c05e4 100644
--- a/dom/plugins/base/PluginPRLibrary.cpp
+++ b/dom/plugins/base/PluginPRLibrary.cpp
@@ -327,11 +327,6 @@ PluginPRLibrary::GetScrollCaptureContainer(NPP aInstance, ImageContainer** aCont
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
-nsresult
-PluginPRLibrary::UpdateScrollState(NPP aInstance, bool aIsScrolling)
-{
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
 #endif
 
 nsresult
diff --git a/dom/plugins/base/PluginPRLibrary.h b/dom/plugins/base/PluginPRLibrary.h
index a369d7654b9e98..b941880a13f465 100644
--- a/dom/plugins/base/PluginPRLibrary.h
+++ b/dom/plugins/base/PluginPRLibrary.h
@@ -127,7 +127,6 @@ class PluginPRLibrary : public PluginLibrary
     virtual void SetHasLocalInstance() override { }
 #if defined(XP_WIN)
     virtual nsresult GetScrollCaptureContainer(NPP aInstance, mozilla::layers::ImageContainer** aContainer) override;
-    virtual nsresult UpdateScrollState(NPP aInstance, bool aIsScrolling) override;
 #endif
     virtual nsresult HandledWindowedPluginKeyEvent(
                        NPP aInstance,
diff --git a/dom/plugins/base/nsNPAPIPluginInstance.cpp b/dom/plugins/base/nsNPAPIPluginInstance.cpp
index ac519d062f7696..fcc02d387079f1 100644
--- a/dom/plugins/base/nsNPAPIPluginInstance.cpp
+++ b/dom/plugins/base/nsNPAPIPluginInstance.cpp
@@ -1161,15 +1161,6 @@ nsNPAPIPluginInstance::GetScrollCaptureContainer(ImageContainer**aContainer)
   AutoPluginLibraryCall library(this);
   return !library ? NS_ERROR_FAILURE : library->GetScrollCaptureContainer(&mNPP, aContainer);
 }
-nsresult
-nsNPAPIPluginInstance::UpdateScrollState(bool aIsScrolling)
-{
-  if (RUNNING != mRunning)
-    return NS_OK;
-
-  AutoPluginLibraryCall library(this);
-  return !library ? NS_ERROR_FAILURE : library->UpdateScrollState(&mNPP, aIsScrolling);
-}
 #endif
 
 nsresult
diff --git a/dom/plugins/base/nsNPAPIPluginInstance.h b/dom/plugins/base/nsNPAPIPluginInstance.h
index 2e7c2f8e253190..65cf2297142c20 100644
--- a/dom/plugins/base/nsNPAPIPluginInstance.h
+++ b/dom/plugins/base/nsNPAPIPluginInstance.h
@@ -122,7 +122,6 @@ class nsNPAPIPluginInstance final : public nsIAudioChannelAgentCallback
   nsresult GetMIMEType(const char* *result);
 #if defined(XP_WIN)
   nsresult GetScrollCaptureContainer(mozilla::layers::ImageContainer **aContainer);
-  nsresult UpdateScrollState(bool aIsScrolling);
 #endif
   nsresult HandledWindowedPluginKeyEvent(
              const mozilla::NativeEventData& aKeyEventData,
diff --git a/dom/plugins/base/nsPluginInstanceOwner.cpp b/dom/plugins/base/nsPluginInstanceOwner.cpp
index 3730c2fb3c7a92..8319d8cdb6dd2b 100644
--- a/dom/plugins/base/nsPluginInstanceOwner.cpp
+++ b/dom/plugins/base/nsPluginInstanceOwner.cpp
@@ -322,21 +322,6 @@ nsPluginInstanceOwner::GetCurrentImageSize()
   return size;
 }
 
-bool
-nsPluginInstanceOwner::UpdateScrollState(bool aIsScrolling)
-{
-#if defined(XP_WIN)
-  if (!mInstance) {
-    return false;
-  }
-  mScrollState = aIsScrolling;
-  nsresult rv = mInstance->UpdateScrollState(aIsScrolling);
-  return NS_SUCCEEDED(rv);
-#else
-  return false;
-#endif
-}
-
 nsPluginInstanceOwner::nsPluginInstanceOwner()
   : mPluginWindow(nullptr)
 {
@@ -384,7 +369,6 @@ nsPluginInstanceOwner::nsPluginInstanceOwner()
   mGotCompositionData = false;
   mSentStartComposition = false;
   mPluginDidNotHandleIMEComposition = false;
-  mScrollState = false;
 #endif
 }
 
diff --git a/dom/plugins/base/nsPluginInstanceOwner.h b/dom/plugins/base/nsPluginInstanceOwner.h
index 9b71f3de9f1662..75d3a6c4c45150 100644
--- a/dom/plugins/base/nsPluginInstanceOwner.h
+++ b/dom/plugins/base/nsPluginInstanceOwner.h
@@ -229,8 +229,6 @@ class nsPluginInstanceOwner final : public nsIPluginInstanceOwner
   // Returns true if this is windowed plugin that can return static captures
   // for scroll operations.
   bool NeedsScrollImageLayer();
-  // Notification we receive from nsPluginFrame about scroll state.
-  bool UpdateScrollState(bool aIsScrolling);
 
   void DidComposite();
 
@@ -411,9 +409,6 @@ class nsPluginInstanceOwner final : public nsIPluginInstanceOwner
 #endif
 
   bool mWaitingForPaint;
-#if defined(XP_WIN)
-  bool mScrollState;
-#endif
 };
 
 #endif // nsPluginInstanceOwner_h_
diff --git a/dom/plugins/ipc/PluginInstanceParent.cpp b/dom/plugins/ipc/PluginInstanceParent.cpp
index 1b632e630629d0..ef179051c4edc5 100644
--- a/dom/plugins/ipc/PluginInstanceParent.cpp
+++ b/dom/plugins/ipc/PluginInstanceParent.cpp
@@ -1209,12 +1209,6 @@ PluginInstanceParent::GetScrollCaptureContainer(ImageContainer** aContainer)
 
   return NS_OK;
 }
-
-nsresult
-PluginInstanceParent::UpdateScrollState(bool aIsScrolling)
-{
-  return NS_OK;
-}
 #endif // XP_WIN
 
 PluginAsyncSurrogate*
diff --git a/dom/plugins/ipc/PluginInstanceParent.h b/dom/plugins/ipc/PluginInstanceParent.h
index 9a4bb68bb43bdc..9f1a26afaf8d48 100644
--- a/dom/plugins/ipc/PluginInstanceParent.h
+++ b/dom/plugins/ipc/PluginInstanceParent.h
@@ -333,7 +333,6 @@ class PluginInstanceParent : public PPluginInstanceParent
 #if defined(XP_WIN)
     nsresult SetScrollCaptureId(uint64_t aScrollCaptureId);
     nsresult GetScrollCaptureContainer(mozilla::layers::ImageContainer** aContainer);
-    nsresult UpdateScrollState(bool aIsScrolling);
 #endif
     void DidComposite();
 
diff --git a/dom/plugins/ipc/PluginLibrary.h b/dom/plugins/ipc/PluginLibrary.h
index 21cce8c683c864..34d60b7d35a0b9 100644
--- a/dom/plugins/ipc/PluginLibrary.h
+++ b/dom/plugins/ipc/PluginLibrary.h
@@ -89,7 +89,6 @@ class PluginLibrary
 #endif
 #if defined(XP_WIN)
     virtual nsresult GetScrollCaptureContainer(NPP aInstance, mozilla::layers::ImageContainer** aContainer) = 0;
-    virtual nsresult UpdateScrollState(NPP aInstance, bool aIsScrolling) = 0;
 #endif
   virtual nsresult HandledWindowedPluginKeyEvent(
                      NPP aInstance,
diff --git a/dom/plugins/ipc/PluginModuleParent.cpp b/dom/plugins/ipc/PluginModuleParent.cpp
index 2eaad73c284463..44ab0e9e7909fa 100755
--- a/dom/plugins/ipc/PluginModuleParent.cpp
+++ b/dom/plugins/ipc/PluginModuleParent.cpp
@@ -2033,12 +2033,6 @@ PluginModuleParent::GetScrollCaptureContainer(NPP aInstance,
     PluginInstanceParent* inst = PluginInstanceParent::Cast(aInstance);
     return !inst ? NS_ERROR_FAILURE : inst->GetScrollCaptureContainer(aContainer);
 }
-nsresult
-PluginModuleParent::UpdateScrollState(NPP aInstance, bool aIsScrolling)
-{
-    PluginInstanceParent* inst = PluginInstanceParent::Cast(aInstance);
-    return !inst ? NS_ERROR_FAILURE : inst->UpdateScrollState(aIsScrolling);
-}
 #endif
 
 nsresult
diff --git a/dom/plugins/ipc/PluginModuleParent.h b/dom/plugins/ipc/PluginModuleParent.h
index e9276248109d0b..c26094b280586d 100644
--- a/dom/plugins/ipc/PluginModuleParent.h
+++ b/dom/plugins/ipc/PluginModuleParent.h
@@ -263,7 +263,6 @@ class PluginModuleParent
 
 #if defined(XP_WIN)
     virtual nsresult GetScrollCaptureContainer(NPP aInstance, mozilla::layers::ImageContainer** aContainer) override;
-    virtual nsresult UpdateScrollState(NPP aInstance, bool aIsScrolling);
 #endif
 
     virtual nsresult HandledWindowedPluginKeyEvent(
diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
index 506411f27850d9..8e4ef39156d1cd 100644
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -1893,7 +1893,6 @@ ScrollFrameHelper::ScrollFrameHelper(nsContainerFrame* aOuter,
   , mZoomableByAPZ(false)
   , mScrollsClipOnUnscrolledOutOfFlow(false)
   , mVelocityQueue(aOuter->PresContext())
-  , mAsyncScrollEvent(END_DOM)
 {
   if (LookAndFeel::GetInt(LookAndFeel::eIntID_UseOverlayScrollbars) != 0) {
     mScrollbarActivity = new ScrollbarActivity(do_QueryFrame(aOuter));
@@ -2006,8 +2005,6 @@ ScrollFrameHelper::AsyncScrollCallback(ScrollFrameHelper* aInstance,
 void
 ScrollFrameHelper::CompleteAsyncScroll(const nsRect &aRange, nsIAtom* aOrigin)
 {
-  NotifyPluginFrames(END_DOM);
-
   // Apply desired destination range since this is the last step of scrolling.
   mAsyncSmoothMSDScroll = nullptr;
   mAsyncScroll = nullptr;
@@ -2023,11 +2020,6 @@ ScrollFrameHelper::CompleteAsyncScroll(const nsRect &aRange, nsIAtom* aOrigin)
 
 #if defined(XP_WIN) || defined(MOZ_WIDGET_GTK)
 struct PluginSearchCtx {
-  enum PluginAction {
-    UPDATE, // Update the scroll visibility of any plugin frames using |value|
-    QUERY   // Set |value| to true if plugin frames were found
-  };
-  PluginAction action;
   nsIFrame* outer;
   bool value;
 };
@@ -2044,11 +2036,7 @@ NotifyPluginFramesCallback(nsISupports* aSupports, void* aCtx)
         // Check to be sure this plugin is contained within a subframe of
         // the nsGfxScrollFrame that initiated this callback.
         if (nsLayoutUtils::IsAncestorFrameCrossDoc(pCtx->outer, plugin, nullptr)) {
-          if (pCtx->action == PluginSearchCtx::UPDATE) {
-            plugin->SetScrollVisibility(pCtx->value);
-          } else if (pCtx->action == PluginSearchCtx::QUERY) {
-            pCtx->value = true;
-          }
+          pCtx->value = true;
         }
       }
     }
@@ -2064,39 +2052,13 @@ NotifyPluginSubframesCallback(nsIDocument* aDocument, void* aCtx)
 }
 #endif
 
-void
-ScrollFrameHelper::NotifyPluginFrames(AsyncScrollEventType aEvent)
-{
-#if defined(XP_WIN) || defined(MOZ_WIDGET_GTK)
-  if (!gfxPrefs::HidePluginsForScroll()) {
-    return;
-  }
-  if (XRE_IsContentProcess()) {
-    // Ignore 'inner' dom events triggered by apz transformations
-    if (mAsyncScrollEvent == BEGIN_APZ && aEvent != END_APZ) {
-      return;
-    }
-    if (aEvent != mAsyncScrollEvent) {
-      nsPresContext* presContext = mOuter->PresContext();
-      PluginSearchCtx ctx = { PluginSearchCtx::UPDATE, mOuter, (aEvent == BEGIN_APZ || aEvent == BEGIN_DOM) };
-      presContext->Document()->EnumerateActivityObservers(NotifyPluginFramesCallback,
-                                                          (void*)&ctx);
-      presContext->Document()->EnumerateSubDocuments(NotifyPluginSubframesCallback,
-                                                     (void*)&ctx);
-
-      mAsyncScrollEvent = aEvent;
-    }
-  }
-#endif
-}
-
 bool
 ScrollFrameHelper::HasPluginFrames()
 {
 #if defined(XP_WIN) || defined(MOZ_WIDGET_GTK)
   if (XRE_IsContentProcess()) {
     nsPresContext* presContext = mOuter->PresContext();
-    PluginSearchCtx ctx = { PluginSearchCtx::QUERY, mOuter, false };
+    PluginSearchCtx ctx = { mOuter, false };
     presContext->Document()->EnumerateActivityObservers(NotifyPluginFramesCallback,
                                                         (void*)&ctx);
     if (ctx.value) {
@@ -2322,7 +2284,6 @@ ScrollFrameHelper::ScrollToWithOrigin(nsPoint aScrollPosition,
   mAsyncScroll->mIsSmoothScroll = isSmoothScroll;
 
   if (isSmoothScroll) {
-    NotifyPluginFrames(BEGIN_DOM);
     mAsyncScroll->InitSmoothScroll(now, mDestination, aOrigin, range, currentVelocity);
   } else {
     mAsyncScroll->Init(range);
diff --git a/layout/generic/nsGfxScrollFrame.h b/layout/generic/nsGfxScrollFrame.h
index e7ffbdb4606ecc..7ba8e45969c161 100644
--- a/layout/generic/nsGfxScrollFrame.h
+++ b/layout/generic/nsGfxScrollFrame.h
@@ -379,7 +379,6 @@ class ScrollFrameHelper : public nsIReflowCallback {
       // because we have special behaviour for it when APZ scrolling is active.
       mOuter->SchedulePaint();
     }
-    NotifyPluginFrames(aTransforming ? BEGIN_APZ : END_APZ);
   }
   bool IsTransformingByAPZ() const {
     return mTransformingByAPZ;
@@ -620,13 +619,6 @@ class ScrollFrameHelper : public nsIReflowCallback {
 
   void CompleteAsyncScroll(const nsRect &aRange, nsIAtom* aOrigin = nullptr);
 
-  /*
-   * Helper that notifies plugins about async smooth scroll operations managed
-   * by nsGfxScrollFrame.
-   */
-  enum AsyncScrollEventType { BEGIN_DOM, BEGIN_APZ, END_DOM, END_APZ };
-  void NotifyPluginFrames(AsyncScrollEventType aEvent);
-  AsyncScrollEventType mAsyncScrollEvent;
   bool HasPluginFrames();
   bool HasPerspective() const;
   bool HasBgAttachmentLocal() const;
diff --git a/layout/generic/nsPluginFrame.cpp b/layout/generic/nsPluginFrame.cpp
index 42a9e857281637..c1ba5e8d1aca1d 100644
--- a/layout/generic/nsPluginFrame.cpp
+++ b/layout/generic/nsPluginFrame.cpp
@@ -153,7 +153,6 @@ nsPluginFrame::nsPluginFrame(nsStyleContext* aContext)
   : nsFrame(aContext)
   , mInstanceOwner(nullptr)
   , mReflowCallbackPosted(false)
-  , mIsHiddenDueToScroll(false)
 {
   MOZ_LOG(sPluginFrameLog, LogLevel::Debug,
          ("Created new nsPluginFrame %p\n", this));
@@ -418,7 +417,7 @@ nsPluginFrame::GetWidgetConfiguration(nsTArray<nsIWidget::Configuration>* aConfi
 #if defined(XP_WIN) || defined(MOZ_WIDGET_GTK)
   if (XRE_IsContentProcess()) {
     configuration->mWindowID = (uintptr_t)mWidget->GetNativeData(NS_NATIVE_PLUGIN_PORT);
-    configuration->mVisible = !mIsHiddenDueToScroll && mWidget->IsVisible();
+    configuration->mVisible = mWidget->IsVisible();
 
   }
 #endif // defined(XP_WIN) || defined(MOZ_WIDGET_GTK)
@@ -772,24 +771,6 @@ nsPluginFrame::IsHidden(bool aCheckVisibilityStyle) const
   return false;
 }
 
-// Clips windowed plugin frames during remote content scroll operations managed
-// by nsGfxScrollFrame.
-void
-nsPluginFrame::SetScrollVisibility(bool aState)
-{
-  // Limit this setting to windowed plugins by checking if we have a widget
-  if (mWidget) {
-    bool changed = mIsHiddenDueToScroll != aState;
-    mIsHiddenDueToScroll = aState;
-    // Force a paint so plugin window visibility gets flushed via
-    // the compositor.
-    if (changed && mInstanceOwner) {
-      mInstanceOwner->UpdateScrollState(mIsHiddenDueToScroll);
-      SchedulePaint();
-    }
-  }
-}
-
 mozilla::LayoutDeviceIntPoint
 nsPluginFrame::GetRemoteTabChromeOffset()
 {
@@ -1138,13 +1119,6 @@ nsPluginFrame::DidSetWidgetGeometry()
 bool
 nsPluginFrame::IsOpaque() const
 {
-#if defined(MOZ_WIDGET_GTK)
-  // Insure underlying content gets painted when we clip windowed plugins
-  // during remote content scroll operations managed by nsGfxScrollFrame.
-  if (mIsHiddenDueToScroll) {
-    return false;
-  }
-#endif
 #if defined(XP_MACOSX)
   return false;
 #elif defined(MOZ_WIDGET_ANDROID)
@@ -1194,14 +1168,6 @@ nsPluginFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                                 const nsRect&           aDirtyRect,
                                 const nsDisplayListSet& aLists)
 {
-#if defined(MOZ_WIDGET_GTK)
-  // Clip windowed plugin frames from the list during remote content scroll
-  // operations managed by nsGfxScrollFrame.
-  if (mIsHiddenDueToScroll) {
-    return;
-  }
-#endif
-
   // XXX why are we painting collapsed object frames?
   if (!IsVisibleOrCollapsedForPainting(aBuilder))
     return;
diff --git a/layout/generic/nsPluginFrame.h b/layout/generic/nsPluginFrame.h
index 18b6c21a398795..193390b4bbcfd1 100644
--- a/layout/generic/nsPluginFrame.h
+++ b/layout/generic/nsPluginFrame.h
@@ -213,11 +213,6 @@ class nsPluginFrame : public nsFrame
 
   void SetInstanceOwner(nsPluginInstanceOwner* aOwner);
 
-  /**
-   * Helper for hiding windowed plugins during async scroll operations.
-   */
-  void SetScrollVisibility(bool aState);
-
   /**
    * HandleWheelEventAsDefaultAction() handles eWheel event as default action.
    * This should be called only when WantsToHandleWheelEventAsDefaultAction()
@@ -337,10 +332,6 @@ class nsPluginFrame : public nsFrame
   RefPtr<nsRootPresContext> mRootPresContextRegisteredWith;
 
   mozilla::UniquePtr<PluginFrameDidCompositeObserver> mDidCompositeObserver;
-
-  // Tracks windowed plugin visibility during scroll operations. See
-  // SetScrollVisibility.
-  bool mIsHiddenDueToScroll;
 };
 
 class nsDisplayPlugin : public nsDisplayItem {
